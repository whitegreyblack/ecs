# map_system

"""Map system: not called every turn but on map change events"""

from source.ecs.components import (Information, Openable, Position, Render,
                                   Tile, TileMap, Visibility)
from source.graph import DungeonNode, WorldGraph
from source.maps import (generate_poisson_array, replace_cell_with_stairs,
                         stringify_matrix, transform_random_array_to_matrix)

from .system import System
from source.common import join


class MapSystem(System):
    def generate_map(self, map_id=None, mapstring=None):
        # clear dictionaries to improve speedup
        if self.engine.world:
            for eid, tile in self.engine.tiles:
                self.engine.positions.remove(eid=eid)
                self.engine.renders.remove(eid=eid)
                self.engine.infos.remove(eid=eid)
            self.engine.visibilities.components.clear()
            self.engine.openables.components.clear()
            self.engine.tiles.components.clear()
        # this assumes map id is already generated by entity_manager.create()
        if map_id is not None:
            world = self.engine.entities.find(eid=map_id)
        else:
            world = self.engine.entities.create()
        # if given a specific mapstring use it instead of a random map
        if mapstring:
            dungeon = [[c for c in row] for row in mapstring.split('\n')]
            tilemap = TileMap(len(dungeon[0]), len(dungeon))
        else:
            random_array = generate_poisson_array(58, 17)
            no_stairs = transform_random_array_to_matrix(random_array, 58, 17, 3)
            dungeon = replace_cell_with_stairs(no_stairs)
            tilemap = TileMap(58, 17)
        self.engine.tilemaps.add(world, tilemap)
        # add tiles and tile specific attribute components
        for y, row in enumerate(dungeon):
            for x, c in enumerate(row):
                tile = self.engine.entities.create()
                self.engine.tiles.add(tile, Tile())
                position = Position(
                    x, 
                    y,
                    map_id=world.id,
                    moveable=False, 
                    blocks_movement=c in ('#', '+')
                )
                self.engine.visibilities.add(tile, Visibility())
                self.engine.positions.add(tile, position)
                self.engine.renders.add(tile, Render(char=c))
                if c == '#':
                    self.engine.infos.add(tile, Information('wall'))
                elif c in ('/', '+'):
                    self.engine.infos.add(tile, Information('door'))
                    self.engine.openables.add(tile, Openable(opened=c=='/'))
                elif c == '<' or c == '>':
                    self.engine.infos.add(tile, Information('stairs'))
                elif c == '"':
                    self.engine.infos.add(tile, Information('grass'))
                elif c == '~':
                    self.engine.infos.add(tile, Information('water'))
                else:
                    self.engine.infos.add(tile, Information('floor'))
        # create world graph if ran the first time
        if not self.engine.world:
            self.engine.world = WorldGraph({
                world.id: DungeonNode(world.id, None)
            }, world.id)
        # update current map to save parent/child relationship
        else:
            self.engine.world.node.child_id = world.id
            current_map_id = self.engine.world.id
            self.engine.world.update({
                world.id: DungeonNode(world.id, current_map_id)
            })
